package mtk.otpcracker

import scala.annotation.tailrec

object Main extends App {
  val charset = ('0' to '9') ++ ('a' to 'z') ++ ('A' to 'Z') ++ Seq(' ', ',', '.', ''')//, '-', '!', '?', '$', ':', '(', ')', '$')
  val xorLookup = (for {
    c0 <- charset
    c1 <- charset
  } yield (c0, c1)).groupBy({ case (c0, c1) => c0 ^ c1 })

  def transpose[A](xss: Seq[Seq[A]]): Seq[Seq[A]] = {
    @tailrec
    def aux(xs: Seq[Seq[A]], acc: Seq[Seq[A]]): Seq[Seq[A]] = xs match {
      case Nil => acc
      case _ =>
        val nonEmpties = xs.filter(_.nonEmpty)
        aux(nonEmpties.map(_.tail), nonEmpties.map(_.head) +: acc)
    }

    aux(xss, Seq()).reverse
  }

  val cs = """7E23AAE32FA0A7A88EE51A18F02FC1CB78A8987CDEBB26A990B39DE31A9DB15B38B9B7C95E3AFC7C89746A1679A84025B1889C9F22D6C92106AF0D54E4D7607779EF7E19C89AED8CD1B9
             |6409C7D508E182B78EF4175DB52085FD6BBD892A9B9871E8ABBFD9E11480F5573AB4F8DE5F37FC7CAD2D391B69E2056DBDDBCF9A3A9AC37443EF1154F4DD392316A21C15A6B8CAA5B89B2FD6C0BD49643ED80EC46D97207A8943EB94D99A5B7CC3257CF3B4C31574A023CC671A846F5B47282B682211E2F802711E89FE44BA342B6496627693BEB927357CB03C362520790489
             |773888862AD5A292EBC22F5D9928C1C139A89F7FDDAE77ECFFE490F213CFFC437BAFB6CB5F3CA9348D68390E30A6446BBCDBE89A32858F260CE40754F3DA706A39AA107CF2A4C7E0FF9320D1D8BD1B223FD3198128C46F7CC153F7DBC6F745338F3863AEB8BA0E76E86FC22B019873124C216F6D3918A5E202714C859959BB753C75D77D6ED2BDB8690533FD367B3920780088AD6465C484573D3DB3628C5C99532FB7013D8729DA3235EBC30E7BF938A742825274B630
             |640D838613E88BFBCFF01418B33A88E777ABCD71D5AB39FEBEE194A60280E44E33BCADD0102CB1338B69665A43A64025AF94C99E3FD6CD2B43E90D54F3C56B6523EF5532A6A1CDB4F1992085D5AB1B2576DF1DCD2D8C6F45D01AF38E94DE4F33943E66B1F0BA1860E92BD9671C8E695B56296F702954B1E70E794B89D544A871742CB6607E93BBB53A7128B2657B3375
             |7E23AAE32FA0B9B2DAFE522FBF3D80E470B6883C9BA260A9B8FB96F50F83E81A3DBBACD4553CE27C8A62715A59EE4D64AE9E9C943484C82117A80A1CE1C6226D36A25970A6ADCCA4B88226C4C0F855253BD85BD261C0206D871AC2B3AFFB6E33AF10468FD1D43944
             |6639ABEF25D4CE8CC6F7065AA36E89ED39AC8571CFEF7FE6B3FF96F108CFE5523EA8BD90103AB53D902D3D1565A24125B694C8D23F97C12D06B75E3AF5C0716677861C37E8A3D5E0F6993A8B
             |4E1993D20FEEC2FBCFB61608B5228DE16AACC130DAEF7DFCBAFF95EF089BAA1A3AFABFD95E3AB139896C245A7FA80571B09E9C843E84D66E05E10C07F4926A6C22BC5970A6A3C4E0EC9E2B85D2B14937229D1DCF25973C6DCA55EA85C6D95D66903429FDF5F25621F327C5671D86761450322E717004A3E3187D5BC6980BAA7C3D2C877B74C7BCFC3B342AB83765396E2C1CC0BC2C6CD1CD04
             |621995D505A0A4BEDDE35E5DA72680FC39B08C63CFAA26A9BCF297A60280E41A35B5AC9C433ABC25C46C3D1279A2403AF8BFD3D22299DA6E0DE70A54F3D7672323A75D28A68582A1F5D621D0C0F8542276DF0EC420C327378970D1ADAFFF68
             |781995C809EE89FBC6FF015DB62F82ED39AC8230CFA77CA9BBF68EAB1F9DFE4A2BB3B6DB103DB2299065645A528B6B5397B7F5BD7BA2C72710A8091DEED62E232EA0497CF2ADCEABB899288994BA572B21CE5CD43297297AC657A48E93C84F768F2776AEAFBA2974F73FC5355482685B462921787C54A3FE0F3C48CC9958B6753460D76D75DEB6FC3D3E33FD2977222A22
             |680394D240F486B4DBB61C12A46E8DE96CBF852F9B8D5CC789DCB5CF34CFDF5577FABBD34A62FD15C47F2B0E78AB5725AF9ED98275D6FD012ECD31
             |6E19938647F487A88EF81D5DA72795A86DB7CD77D4E139C49AC1BAD32FA6DE1A0CB2A1901023BC25C462241F30AF566EE7DBEEBD16B3E0
             |7804828605F88DAEDDF35209B82F95A86DB082659BAB76FAABB394E7108AB15335FAACD4593DFD3881612B0330875625B494D2953E848F3A0BE91054F4DA672323AE5039A6B8CAAFEDD62ACAC7AC1B212EDE09D224996F41DA1AF0899F9A5276942233BAFBF51E2DA720D267168A7F440227216E2711B0B01F731FDDD14AAA2F785F96773AD6BAA821342EF16577382B2C218FB56024C3D0442B68A062C908954F3EBC54279D29D37C37AE8D
             |7F0486CA0CA08CB2DAE2170FBC37C1EA7CBF847E9BA770FAFFF59CE70989E4567BBEB9C8556E8A3590656A0E78A75625B692DB9A2FD1DC6E11ED0811ECC1226239AB1C39FEBCCBB2FDD63ACDD1F84F2124D05CEE27972E28CD5FF7918FC95977C33D7ABBF1BA196DE83CC5235482755B4F3F6F7F2211A3E31F3C7DD09958B1793D2C816776D6F3BA26233AB82C6276206A48DDB7786DDDC1492B68B06FCD5C9E08
             |6639ABEF25D4CEFCFAFF015DB1228CE76AACCD7DD4BD77E0B1F4C2A632CFE6552EB6BC9C582FAB39C479221F75EE426AB69E86D21A98CB6E1AED0A54EEDD226522BD4834E3BE82B4F0972085D5F84C2538C913CF66C46F6AC048E0DAC6ED547CC33D76A9E7BA1375A727CF37548A3B174B323B713554A4E204711FC1DC59FE7C39629322
             |7E23AAE32FA0A0BEC7E21A18A262C1EE78B19F30C8AE70E7ABBFD9EF1DCFF4532FB2BDCE103AB539812D2E1363A24C6EBDD59CB80EBAE60B37A8361BF79261623AAA4F28A6B8CAAFEDD626CCC0B05E367A9D08C42DDB6F65CC16A48088DE1C648B3461B8F2F50864B8
             |6D0283860DEF9CBE8EFF1C1EBF2092FC78B69930CFA778E7FFE791E35B98F8543FF6F8CB5821FD2B8B622F09308B5360B6DBD29D2CD6DB2606A81806EFC8676D77AD532FE9A182AFFED63ACDD1F8552B24C9148D61F6216C851AE6848FD45B33823F74B8E6BD1E2DA73FD52112983B1A5527363D3606ADFD4B6857CCD748BB387858827C74DABDBB693935AE6570372C6948DCB62C70D8C105362DA327C85A99563CB64F2DCE2EDD6720A399
             |6E19938614EFCEAFC6F35218B13C95E039AB827DDEEF6AF9BAF090E717CFF65534BEF8D85F3AB57C83643C1F3CEE6B6AAADBDD873C9EDB6E10E75E13EFDD662335BA487CF5B8D0A1F19869C194BE492B3B9D08C920C36F6EC853F6C193C95933B13465B2F8EE0921E13DCF2A549F690E47662D742200AABC4B6F4BDCD449B27D366BD7617493B2BE3C2239E765403F3D781DCDF96570C3C1493468A07FDE4685063AB6422FC27DD0773DA5D04B78F42EB41299576EA07A0D
             |6115C7CA09E68BFBD9F30018F02C84FC6DBD9F30DEA17DECBBB39BFF5B9BF95F32A8F8D4513AB870C459221B7EEE4160B98FD4D22B84C03C0CEF0B11E49E227436A14835E8AB82AFFED63ACDCDF8572B20D852810BE20341EC6EA4A39F9A4B7B8C2276FDF0F30864E43BC9281ACB7D1457282B3A2300E2E403734A89D65EAA342C649E7D3AC3BFBD2A3463
             |6A0395860DE580FBDDF95212BC2AC1E96AF89A759BBB76A9B4F69CF65B9BF95F7BAABDDD532BF37CB44C183343EE6A63F893D39C3483DD2F01E41B54F2D7616838A15532E1ECC3B2FDD637CAC1F8592B22D5478100D92B28D953F098C69D487A90716AB2E1BA1668F12AC467159F3B1446223C3D231BE2FC04725887
             |621995D505A0A0B48EFA170EA36FC1E678A1C130D9A67EEEBAE1C2A60C80FC5F35FABFCE5F39FD3E9D2D271F7EE0054999BFE5D218B7FF1B2FCD2A54D3C267623CEF5E2EEFA9C4ACE1DA6EC6D5B61B3D39C85CCD28DC2A28C65CA4B187C85560C4717FB2E2FF45
           """.stripMargin
    .split("\n")
    .map {
      _.trim().sliding(2, 2).map(Integer.parseInt(_, 16)).toSeq
    }.toSeq

  val thirdLine = "[To JULIET] If I profane with my unworthiest hand This holy shrine, the gentle fine is this: My lips, two blushing pilgrims, ready stand To smooth that rough touch with a tender kiss."

  val key = cs(2).zip(thirdLine).map({ case (c0, c1) => c0 ^ c1 })

  for (c <- cs) println(c.zip(key).map({ case (c0, c1) => (c0 ^ c1).toChar }).mkString)

  def xyz[A](s0: Seq[(A, A)], s1: Seq[(A, A)]): (Seq[(A, A)], Seq[(A, A)]) = {
    val intersect = (s0.map(_._2) intersect s1.map(_._1)).toSet
    (s0.filter(a => intersect.contains(a._2)), s1.filter(a => intersect.contains(a._1)))
  }

  def wxyz[A](s0: Seq[(A, A)], s1: Seq[(A, A)]): Seq[A] = (s0.map(_._2) intersect s1.map(_._1)).distinct

  def asd[A](s0: Seq[(A, A)], s1: Seq[(A, A)]): (Seq[A], Seq[A], Seq[A]) = {
    val intersect = (s0.map(_._2) intersect s1.map(_._1)).toSet
    (s0.filter(s => intersect.contains(s._2)).map(_._1), intersect.toSeq, s1.filter(s => intersect.contains(s._1)).map(_._2))
  }

  def tryDecode(ciphertexts: Seq[Int], xorLookup: Map[Int, Seq[(Char, Char)]]): Map[Int, Seq[Char]] = {
    val uniqueCiphertexts = ciphertexts.distinct

    val ciphertextXors = for {
      ciphertext0 <- uniqueCiphertexts
      ciphertext1 <- uniqueCiphertexts
      if ciphertext0 != ciphertext1
    } yield ((ciphertext0, ciphertext1), xorLookup(ciphertext0 ^ ciphertext1))

    val narrowedGuesses = ciphertextXors.map { case ((c0, c1), s) =>
      Seq((c0, s.map(_._1)), (c1, s.map(_._2)))
    }

    narrowedGuesses.flatten.groupBy(_._1).mapValues(v => v.map(_._2).reduce(_ intersect _))
  }

  def tryDecodeAll(ciphertexts: Seq[Seq[Int]], xorLookup: Map[Int, Seq[(Char, Char)]]): Seq[String] = {
    val transposedCiphertexts = transpose(ciphertexts)

    val decoders = transposedCiphertexts.map(tryDecode(_, xorLookup))

//    decoders.foreach(println(_))

    ciphertexts.map { ciphertext =>
      (ciphertext zip decoders).map({ case (c, d) =>
        d.get(c) match {
          case Some(Seq(x)) => x
          case _ => '?'
        }
      }).mkString
    }
  }

  def tryGuessKey(ciphertexts: Seq[Seq[Int]], xorLookup: Map[Int, Seq[(Char, Char)]]): Seq[String] = {
    val transposedCiphertexts = transpose(ciphertexts)

    val decoders = transposedCiphertexts.map(tryDecode(_, xorLookup))

    decoders.map(_.toString) ++
    decoders.map { decoder =>
      decoder.flatMap { case (ciphertext, chrs) =>
        chrs.map(_ ^ ciphertext).groupBy(x => x | 32).keys
      }.toSeq.distinct match {
        case Seq(x) => x.toString
        case xs => xs.sorted.mkString("[", ", ", "]")
      }
    }
  }

//  println(tryGuessKey(cs, xorLookup).mkString("\n"))
//  println(tryDecodeAll(cs, xorLookup).mkString("\n"))
}